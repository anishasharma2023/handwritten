# -*- coding: utf-8 -*-
"""Copy of handwriting_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UC0DciFwmqllUiSSmKWPytJqcbYYX6B_

**Handwritten Digit Classification with TensorFlow

This project focuses on building and training a neural network to recognize handwritten digits using the TensorFlow library. We aim to process the MNIST dataset, construct a model, and develop a simple GUI for real-time digit classification.
"""

# Importing TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import RMSprop

# Helper libraries for array operations and plotting
import numpy as np
import matplotlib.pyplot as plt

# Display TensorFlow version to ensure it's correctly loaded
print("TensorFlow version:", tf.__version__)
print("Numpy version:", np.__version__)

#The MNIST dataset is a collection of 28x28 grayscale images of handwritten digits (from 0 to 9)
#and their corresponding labels. TensorFlow provides easy access to this dataset, and it is commonly
#used for training and testing in the field of machine learning.

mnist = tf.keras.datasets.mnist
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

#After running this code, you will have the training images and labels in train_images
# and train_labels, respectively. Similarly, you will have the test images and labels
# in test_images and test_labels.

# The print statements are there to confirm that the data has been loaded correctly. You should see the following output:

print("Training data shape:", train_images.shape)
print("Training labels shape:", train_labels.shape)
print("Test data shape:", test_images.shape)
print("Test labels shape:", test_labels.shape)

#This step is to make sure the mnist data is loaded and visualize the image in the dataset.

plt.figure(figsize=(8,8))
plt.imshow(train_images[0], cmap=plt.cm.binary)
plt.colorbar()
plt.grid(False)
plt.title("First image in the training dataset")
plt.show()

# Print the corresponding label
print("Label for the first training image:", train_labels[0])

#Build the Neural Network Model

# Define the model
model = keras.Sequential([
    # Flatten layer to transform the images from a 2d-array (28 by 28 pixels)
    # to a 1d-array of 784 pixels.
    keras.layers.Flatten(input_shape=(28, 28)),
    # Dense hidden layer with ReLU activation
    keras.layers.Dense(300, activation='relu'),
    keras.layers.Dropout(0.2),
    keras.layers.Dense(50, activation='relu'),
    # Dropout layer to reduce overfitting
    keras.layers.Dropout(0.3),
    # Output layer with 10 neurons (one for each class) with softmax activation
    keras.layers.Dense(10, activation='softmax')
])


# Display the model's architecture
model.summary()

# Compile the model
model.compile(loss='sparse_categorical_crossentropy',
              optimizer=tf.keras.optimizers.Adam(0.0003),
              metrics=['accuracy'])

# Train the model by fitting it to the training data
early_stopping = EarlyStopping(monitor='val_loss', patience=3)

history = model.fit(train_images, train_labels,
                    epochs=15,
                    validation_split=0.1,
                    callbacks=[early_stopping])

# Evaluate the model on the test dataset
test_loss, test_accuracy = model.evaluate(test_images,
                                          test_labels,
                                          verbose=2)

# Print out the accuracy
print('\nTest accuracy:', test_accuracy)

# Save the model
model.save('model')